/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
import{Agent,State,Command}from"./infra/events.esm.js";import FreeQueue from"./infra/free-queue.esm.js";const DEFAULT_BUFFER_SIZE=256,DEFAULT_CHANNEL_COUNT=2,CLIENT_GLOBAL_SCOPE_FILE="client-global-scope.js",AUDIO_SINK_FILE="audio-sink.js";let LIBRARY_PATH="";function SET_LIBRARY_PATH(t){const e=new URL(t,window.location.href);LIBRARY_PATH=e.href}class AudioDeviceClient{constructor(t){this._context=new AudioContext,this._agent=Agent.Controller,this._state=State.Pending,this._constraints=this._sanitizeConstraints(t),this._context.destination.channelCount=t.channelCount,this._context.destination.channelCountMode="explicit",this._context.destination.channelInterpretation="discrete"}_sanitizeConstraints(t){return t||(t={}),{callbackBufferSize:t.callbackBufferSize||DEFAULT_BUFFER_SIZE,channelCount:t.channelCount||DEFAULT_CHANNEL_COUNT,sampleRate:t.sampleRate||this._context.sampleRate}}async initialize(){this._sharedBuffer=FreeQueue.createSharedBuffer(4*this._constraints.callbackBufferSize,this._constraints.channelCount);try{await this._context.audioWorklet.addModule(LIBRARY_PATH+AUDIO_SINK_FILE)}catch(t){throw t}this._workletNode=new AudioWorkletNode(this._context,"audio-sink",{outputChannelCount:[this._constraints.channelCount]}),this._workletNode.connect(this._context.destination),this._workletNode.port.onmessage=this._handleMessage.bind(this),this._workletNode.agent=Agent.Consumer,this._workletNode.state=State.Pending,this._worker=new Worker(LIBRARY_PATH+CLIENT_GLOBAL_SCOPE_FILE),this._worker.onmessage=this._handleMessage.bind(this),this._worker.agent=Agent.Producer,this._worker.state=State.Pending,this._notifyBackends(Command.Initialize,{constraints:this._constraints,sharedBuffer:this._sharedBuffer})}_notifyBackends(t,e){const n={command:t,payload:e};this._workletNode.port.postMessage(n),this._worker.postMessage(n)}_maybeChangeControllerState(t){this._workletNode.state===t&&this._worker.state===t&&(this._state=t)}_handleMessage(t){const e=t.data.agent,n=t.data.state;switch(e){case Agent.Consumer:this._workletNode.state=n,this._maybeChangeControllerState(n);break;case Agent.Producer:this._worker.state=n,this._maybeChangeControllerState(n);break;default:throw Error()}}_untilMessageReceived(){return new Promise(t=>{this._worker.addEventListener("message",e=>t(),{once:!0})})}async addModule(t){const e=new URL(t,window.location.href);this._worker.postMessage({command:Command.LoadScript,payload:{scriptPath:e.href}}),await this._untilMessageReceived()}start(){if(this._state!==State.StandBy)throw Error();this._notifyBackends(Command.Start)}stop(){if(this._state!==State.Running)throw Error;this._notifyBackends(Command.Stop)}close(){if(this._state===State.Closed)throw Error;this._notifyBackends(Command.Close)}}const requestAudioDeviceClient=async t=>{const e=new AudioDeviceClient(t);return await e.initialize(),e};navigator.mediaDevices.requestAudioDeviceClient=requestAudioDeviceClient;export{requestAudioDeviceClient,SET_LIBRARY_PATH};